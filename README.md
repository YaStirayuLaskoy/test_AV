# Test AV
Тестовое AV Soft.

## Описание:
Имеется микросервисная система в которой происходит общение между компонентами через RabbitMQ. Долговременные данные хранятся в MySQL, обратить внимание на 
отказоустойчивость и настройку. Дальнейшее описание подразумевает необходимые моменты, но при этом не являются ограничениями
Описание компонентов:


## Компонент «Ищейка»
Ожидает появления файлов в папке и обрабатывает их: при нахождении текстового
файла (подразумеваются обычные файлы формата txt – с указанием формата или без указания) - перекладывает его в volume «Анализатора» и передает json сообщение посредством 
очереди: «Parsing», в сообщении указывает путь до найденного файла после его перемещения. Если тип файла не текстовый, тогда переложить файл в volume «Ошибочников» и отправить сообщение в «Errors»; в сообщении указывает путь до найденного файла после его 
перемещения.
Обратить внимание:
• По каждому файлу должно быть отправлено только одно сообщение.
• Файлы должны доставаться через volume
• Должны иметь общий volume с «Анализатором» и «Ошибочниками»


## Компонент «Анализатор»
Обрабатывает сообщения очереди: «Parsing»: извлекает слова из текста и записывает 
их в таблицу MySQL с указанием количества вхождений в тексте (для каждого слова, соответственно). В качестве разделителя слов используются все не буквенные символы.
Обратить внимание:
• Должны иметь один общий volume на все экземпляры компонента
Компонент «Ошибочник»
Оповещает посредством электронной почты/телеграмма/SIEM/SOAR (несколько на 
выбор с возможностью настройки, можно добавлять свои цели), в случае получения сообщения из очереди: «Errors»
Обратить внимание:
• В случае ошибки отправки оповещения, оповещение должно произойти позднее.
• Должны иметь один общий volume на все экземпляры компонента


## Компонент «Чтец-мудрец» 
Обрабатывает данные таблицы в MySQL: когда слово встретилось N раз и более уведомление на почту/телеграмм/SIEM/SOAR (несколько на выбор с возможностью настройки, 
можно добавлять свои цели), в котором содержится само слово, а так же пути до файлов, 
содержащих данное слово. После чего счётчик должен быть обнулён, а пути до файлов которые это слово содержали должны быть забыты (Не должны участвовать в следующем сообщении при отправки). Так же имеет HTTP-сервер предоставляющий REST-API для получения информации о текущем состоянии парсинга (Текущее количество слов, количество 
файлов и далее на усмотрение)


## Компонент «Генератор»
Ищет страницы сайта (аналогично поисковому роботу и составлению sitemap.xml) и 
записывает содержимое каждой страницы в отдельный файл, в volume «Ищейки». Настройка 
происходит через конфигурационный файл


## Требования:
• Все компоненты должны быть обёрнуты в docker-образы
◦ У каждого компонента должен быть свой Dockerfile
◦ При сборке образа не должны выполняться лишние инструкции или копироваться 
лишние файлы
◦ Каждый компонент должен иметь отдельную директорию для docker контекста
◦ Запуск контейнеров необходимо производить через docker-compose
• Отказоустойчивость каждого отдельного компонента
◦ Защита от отправленных сообщений
◦ Каждый пришедший файл ОБЯЗАН быть обработан даже в случае экстренного перезапуска компонентов
◦ Каждый компонент должен иметь возможность запускаться в нескольких экземплярах без конфликтов
◦ Обязательна обработка исключений (или конкретных или хотя бы любого рода), которые 
очевидны либо исходя из docstring функций, либо исходя из типа операции (I/O, например).
• Журналирование событий
◦ Отдельные журналы для каждого из компонентов с ежедневной ротацией (Если силами ОС, то приложить конфигурационный файл для ПО)
• Настройка компонентов
◦ Каждый компонент должен настраиваться через json/yaml конфигурацию которая 
примонтирована через volume
◦ Конфигурационные файлы должны быть разделены на настройки данные для работы с инфраструктурой и пользовательскими настройками. При создании экземпляров компонентов должна быть удобная возможность выбора пользовательской 
конфигурации, с которой работать.
• Валидация и типизация
◦ Вместо словарей (dict) там, где это возможно, нужно использовать классы на основе BaseModel из модуля pydantic (с валидацией данных и обработкой случаев, если данные невалидны)
◦ Обязательно использование типизации: в случаях, когда линтер кода не может точно определить тип переменной/выходных данных функции – типы нужно указать самостоятельно. 
Для входных аргументов функций и классов типизация обязательна. Для переменных 
класса типизация обязательна.


## Технологический стек:
• СУБД: MySQL
• Брокер сообщений: RabbitMQ
• Контейнеризация: Docker, Containerd
• Библиотеки: pika для работы с RabbitMQ, для mysql по желанию, Flask или FastAPI как 
HTTP-серве
